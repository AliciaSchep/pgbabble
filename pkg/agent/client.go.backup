package agent

import (
	"context"
	"fmt"
	"os"

	"github.com/anthropics/anthropic-sdk-go"
	"github.com/anthropics/anthropic-sdk-go/option"
)

// Client wraps the Anthropic API client with conversation management
type Client struct {
	anthropic *anthropic.Client
	registry  *ToolRegistry
	history   *ConversationHistory
	model     anthropic.Model
}

// NewClient creates a new agent client
func NewClient(apiKey string) (*Client, error) {
	if apiKey == "" {
		apiKey = os.Getenv("ANTHROPIC_API_KEY")
	}
	if apiKey == "" {
		return nil, fmt.Errorf("Anthropic API key is required (set ANTHROPIC_API_KEY environment variable)")
	}

	client := anthropic.NewClient(
		option.WithAPIKey(apiKey),
	)

	return &Client{
		anthropic: client,
		registry:  NewToolRegistry(),
		history:   &ConversationHistory{},
		model:     anthropic.ModelClaude3_5SonnetLatest,
	}, nil
}

// RegisterTool adds a tool to the agent's registry
func (c *Client) RegisterTool(tool *Tool) error {
	return c.registry.RegisterTool(tool)
}

// SendMessage sends a message to the LLM and handles tool calls
func (c *Client) SendMessage(ctx context.Context, message string) (*Response, error) {
	// Add user message to history
	c.history.AddUserMessage(message)

	// Create system message for SQL generation
	systemMessage := `You are a PostgreSQL expert assistant that helps users write SQL queries.

Your role:
1. Help users write SQL queries based on their natural language requests
2. Use the provided database schema tools to understand the database structure
3. Generate accurate, efficient SQL queries
4. Explain what the query does

Guidelines:
- Always use the schema tools to understand table structures before writing queries
- Generate PostgreSQL-compatible SQL
- Be clear about what data will be returned
- If you need more information about the schema, use the available tools
- Focus on correctness and clarity

Available tools let you:
- list_tables: See all tables and views
- describe_table: Get detailed table structure including columns, types, and relationships
- get_relationships: Find foreign key relationships for a table
- search_columns: Find columns matching a pattern across tables

Always start by exploring the schema if you're not familiar with the database structure.`

	// Convert our messages to Anthropic format
	messages := make([]anthropic.MessageParam, len(c.history.Messages))
	for i, msg := range c.history.Messages {
		if msg.Role == "user" {
			content, ok := msg.Content.(string)
			if !ok {
				content = fmt.Sprintf("%v", msg.Content)
			}
			messages[i] = anthropic.NewUserMessage(
				anthropic.NewTextBlock(content),
			)
		} else {
			// Handle assistant messages with potential tool content
			messages[i] = c.convertAssistantMessage(msg)
		}
	}

	// Convert tools to Anthropic format
	tools := c.registry.GetAllTools()
	anthropicTools := make([]anthropic.ToolUnionParam, len(tools))
	for i, tool := range tools {
		anthropicTools[i] = anthropic.ToolUnionParamOfTool(
			anthropic.ToolInputSchemaParam{
				Type:       anthropic.String("object"),
				Properties: tool.InputSchema.Properties,
				Required:   tool.InputSchema.Required,
			},
			tool.Name,
		)
	}

	// Make request to Anthropic
	response, err := c.anthropic.Messages.New(ctx, anthropic.MessageNewParams{
		Model:     anthropic.F(c.model),
		MaxTokens: anthropic.Int(4000),
		System: []anthropic.MessageNewParamsSystemUnion{
			anthropic.NewTextBlock(systemMessage),
		},
		Messages: anthropic.F(messages),
		Tools:    anthropic.F(anthropicTools),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get response from Anthropic: %w", err)
	}

	// Process response and handle tool calls
	return c.processResponse(ctx, response)
}

// convertAssistantMessage converts our assistant message format to Anthropic format
func (c *Client) convertAssistantMessage(msg Message) anthropic.MessageParam {
	switch content := msg.Content.(type) {
	case string:
		return anthropic.NewAssistantMessage(
			anthropic.NewTextBlock(content),
		)
	case []ContentBlock:
		blocks := make([]anthropic.ContentBlockParamUnion, len(content))
		for i, block := range content {
			switch block.Type {
			case "text":
				blocks[i] = anthropic.NewTextBlock(block.Text)
			case "tool_use":
				blocks[i] = anthropic.NewToolUseBlock(block.ID, block.Input, block.Name)
			case "tool_result":
				var resultContent anthropic.ToolResultBlockParamContentUnion
				if block.IsError {
					resultContent = anthropic.NewTextBlock(block.Content)
				} else {
					resultContent = anthropic.NewTextBlock(block.Content)
				}
				blocks[i] = anthropic.NewToolResultBlock(block.ToolUseID)
				// Note: Setting content and error status would need to be handled differently
				// This is a simplified version
			default:
				blocks[i] = anthropic.NewTextBlock(fmt.Sprintf("%v", block))
			}
		}
		return anthropic.NewAssistantMessage(blocks...)
	default:
		return anthropic.NewAssistantMessage(
			anthropic.NewTextBlock(fmt.Sprintf("%v", content)),
		)
	}
}

// processResponse handles the Anthropic response and executes any tool calls
func (c *Client) processResponse(ctx context.Context, response *anthropic.Message) (*Response, error) {
	var assistantContent []ContentBlock
	var toolUses []ContentBlock

	// Process response content
	for _, content := range response.Content {
		switch block := content.(type) {
		case *anthropic.TextBlock:
			assistantContent = append(assistantContent, ContentBlock{
				Type: "text",
				Text: block.Text,
			})
		case *anthropic.ToolUseBlock:
			toolBlock := ContentBlock{
				Type:  "tool_use",
				ID:    block.ID,
				Name:  block.Name,
				Input: block.Input.(map[string]interface{}),
			}
			assistantContent = append(assistantContent, toolBlock)
			toolUses = append(toolUses, toolBlock)
		}
	}

	// Add assistant message to history
	c.history.AddAssistantMessage(assistantContent)

	// Execute tools if any
	var toolResults []ToolExecutionResult
	if len(toolUses) > 0 {
		for _, toolUse := range toolUses {
			result, err := c.registry.ExecuteTool(ctx, toolUse.Name, toolUse.Input)
			if err != nil {
				result = &ToolResult{
					Content: fmt.Sprintf("Error executing tool %s: %v", toolUse.Name, err),
					IsError: true,
				}
			}

			// Add tool result to history
			c.history.AddToolResult(toolUse.ID, result)

			toolResults = append(toolResults, ToolExecutionResult{
				ToolName: toolUse.Name,
				Input:    toolUse.Input,
				Result:   result,
			})
		}

		// If tools were executed, make another request to get the final response
		return c.sendFollowUpRequest(ctx)
	}

	// No tools were used, return the response directly
	return &Response{
		Content:     c.extractTextContent(assistantContent),
		ToolResults: toolResults,
		RawContent:  assistantContent,
	}, nil
}

// sendFollowUpRequest sends a follow-up request after tool execution
func (c *Client) sendFollowUpRequest(ctx context.Context) (*Response, error) {
	// Convert messages to Anthropic format
	messages := make([]anthropic.MessageParam, len(c.history.Messages))
	for i, msg := range c.history.Messages {
		if msg.Role == "user" {
			content, ok := msg.Content.(string)
			if !ok {
				content = fmt.Sprintf("%v", msg.Content)
			}
			messages[i] = anthropic.NewUserMessage(
				anthropic.NewTextBlock(content),
			)
		} else {
			messages[i] = c.convertAssistantMessage(msg)
		}
	}

	// Get tools
	tools := c.registry.GetAllTools()
	anthropicTools := make([]anthropic.ToolUnionParam, len(tools))
	for i, tool := range tools {
		anthropicTools[i] = anthropic.ToolUnionParamOfTool(
			anthropic.ToolInputSchemaParam{
				Type:       anthropic.String("object"),
				Properties: tool.InputSchema.Properties,
				Required:   tool.InputSchema.Required,
			},
			tool.Name,
		)
	}

	// Make follow-up request
	response, err := c.anthropic.Messages.New(ctx, anthropic.MessageNewParams{
		Model:     anthropic.F(c.model),
		MaxTokens: anthropic.Int(4000),
		Messages:  anthropic.F(messages),
		Tools:     anthropic.F(anthropicTools),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get follow-up response: %w", err)
	}

	// Process the follow-up response (should not have more tool calls)
	var content []ContentBlock
	for _, block := range response.Content {
		if textBlock, ok := block.(*anthropic.TextBlock); ok {
			content = append(content, ContentBlock{
				Type: "text",
				Text: textBlock.Text,
			})
		}
	}

	// Add final assistant response to history
	c.history.AddAssistantMessage(content)

	return &Response{
		Content:    c.extractTextContent(content),
		RawContent: content,
	}, nil
}

// extractTextContent extracts text from content blocks
func (c *Client) extractTextContent(blocks []ContentBlock) string {
	var text string
	for _, block := range blocks {
		if block.Type == "text" {
			text += block.Text
		}
	}
	return text
}

// ClearHistory clears the conversation history
func (c *Client) ClearHistory() {
	c.history.Clear()
}

// GetHistory returns the current conversation history
func (c *Client) GetHistory() *ConversationHistory {
	return c.history
}

// Response represents the agent's response
type Response struct {
	Content     string                  `json:"content"`
	ToolResults []ToolExecutionResult   `json:"tool_results,omitempty"`
	RawContent  []ContentBlock          `json:"raw_content,omitempty"`
}

// ToolExecutionResult represents the result of executing a tool
type ToolExecutionResult struct {
	ToolName string                 `json:"tool_name"`
	Input    map[string]interface{} `json:"input"`
	Result   *ToolResult            `json:"result"`
}